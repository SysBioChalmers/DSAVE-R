---
title: "DSAVE package"
author: "Johan Gustafsson, Juan Inda"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{DSAVE}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  
  chunk_output_type: console
---


```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE, fig.width = 7,
  comment = "#>"
)
```

## 1 Overview

DSAVE (Down-SAmpling based Variation Estimation) is a package that can be used for 
investigating the cell-to-cell variation in single-cell RNA-Seq data. DSAVE divides the variation 
into two components; sampling noise and BTM (Biological, Technical and Misclassification) 
variation. The sampling noise is a function of the number of reads per cell, while the BTM 
variation contains interesting information about technical artefacts, biological variation, 
and cell misclassifications. The sampling noise typically varies between datasets and is often 
the dominating variation factor, often obscuring the BTM variation if not separated with a 
method such as DSAVE.

BTM variation can be explained the following way: For each mapped read from a cell in a cell 
population, there is a certain chance that this will belong to a certain gene. This probability
is based on the mean expression of that gene in the entire population. If no BTM variation exists,
the reads will be sampled according to these gene probabilities the same way in all cells, and we 
will get only sampling noise. In this context, BTM variation is the variation between cells in the 
probabilities used when sampling reads.

The package works on cell populations containing similar cells. The cells are expected to 
be classified into cell types if the dataset has a mix of cell types, and the total cell 
population need to be divided into populations per cell type to give meaningful results. 
We have shown that if the BTM variation of a whole cell population is large compared 
to other datasets, the reason for this is most likely technical; biological variation 
is often smaller when compared over the whole gene range.


DSAVE supports 4 types of calculations:

 * DSAVE Total Variation Estimation - This metric measures the total variation, including sampling noise, 
 for the mean expression over a gene range for a pool of single-cells of a certain size. The metric is 
 useful for determining the pool size needed to obtain the same variation as in for example typical bulk 
 RNA-Seq data. The calculations include generation of sampling noise only (SNO) datasets, which are 
 randomly generated by sampling from a multinomial distribution with probabilities calculated from the 
 mean expression of the cell population.
 
 * DSAVE BTM Variation Score - gives an overall score of the variation. The function uses a template, 
 which is used for making the metric comparable across cell populations and even datasets. The score 
 from a dataset can be compared to that of other datasets to see that the technical variation is comparable
 to that of others.
 
 * DSAVE Gene-Wise Variation - This metric measures the BTM variation per gene, in similar ways as the BTM 
 variation score. Due to sampling stochasticity, the variation of a gene may however vary just by chance. We 
 therefore also produce p values describing the probability that the variation comes from sampling only 
 (the null hypothesis). For the BTM score this is not a problem since the result is averaged over many genes, 
but for the gene-wise metric this needs to be taken into account. The gene-wise metric is not comparable 
across datasets.
 
 * DSAVE Cell-Wise Variation - This metric measures the log-likelihood for that a cell is sampled from the 
 mean expression of the cell population. The lower (more negative) the log-likelihood is, the the cell 
 diverges from the mean of the population. The metric is comparable between cells in a cell population,
 but not across cell populations or datasets. The metric can for example be useful for finding thresholds
 for known cell filtration metrics, such as UMI counts and MT gene content.



## 2 Total Variation

- Load the package.

```{r}
library(ggplot2)
library(DSAVE)
library(progress)
```

- Download the datasets to analyze.

```{r}
bcells <- loadOrDownloadB10k()
tcells <- loadOrDownloadT4k()
```

- Calculate the Total Variation for different pool sizes.

```{r}
scTotalVariation_bcells <- list()
scTotalVariation_tcells <- list()
pools <- c(100, 200, 500, 750, 1000, 1500, 2000, 3000, 4000, 5000)
pools2 <- c(100, 200, 500, 750, 1000, 1500, 2250)
pb <- progress_bar$new(format = "Calculating [:bar] :percent eta: :eta",
                       total = length(pools) + length(pools2), clear = FALSE)

for(poolSize in pools){
  scTotalVariation_bcells[[as.character(poolSize)]] <- DSAVEGetTotalVariationPoolSize(bcells,
        poolSize = poolSize, upperBound = 1e5, lowerBound = 5e-1)
  pb$tick();
}

for(poolSize in pools2){
  scTotalVariation_tcells[[as.character(poolSize)]] <- DSAVEGetTotalVariationPoolSize(tcells,
          poolSize = poolSize, upperBound = 1e5, lowerBound = 5e-1)
  pb$tick();
}

pb$terminate()

```

- Plot the results

```{r , fig.show = 'asis'}
bulkMean1Vs1 <- rep(mean(bulkTotalVar1vs1[[1]][[2]]), 2)
bulkMean4Vs4 <- rep(mean(bulkTotalVar4vs4[[1]][[2]]), 2)
sc <- rbind(
  cbind(pools, sapply(scTotalVariation_bcells, 
                      function(v) mean(v)), "B10k", "sc"), 
  cbind(pools2, sapply(scTotalVariation_tcells, 
                       function(v) mean(v)), "T4k", "sc"), 
  cbind(c(pools[1],pools[length(pools)]), 
        bulkMean1Vs1, "single bulk sample", "bulk"),
  cbind(c(pools[1],pools[length(pools)]), 
        bulkMean4Vs4, "mean of 4 bulk samples", "bulk"))

sc <- as.data.frame(sc)
colnames(sc) <- c("PoolSize", "TotalVariation", "Dataset", "DataType")
sc$PoolSize <- as.numeric(as.character(sc$PoolSize))
sc$TotalVariation <- as.numeric(as.character(sc$TotalVariation))

ggplot(sc, aes(x=PoolSize, y=TotalVariation, group = Dataset)) +
  ggtitle("Variation per Cell Pool Size, CPM > 0.5") +
  geom_line(aes(color = Dataset, linetype = DataType)) +
  ylim(0, max(sc$TotalVariation)) +
  theme(legend.title = element_text(size = 10),
        legend.justification = c(1, 1),
        legend.position = c(1, 1),
        legend.text = element_text(size = 8),
        axis.text.x = element_text(size = 10, angle = 90),
        axis.text.y = element_text(size = 10)) + 
  #ylab(bquote('Variation ( ~ R[mean])')) +
  labs(y=expression(paste(Variation (R[mean] ))),
       x="Pool size (number of cells)") +
  guides(linetype = FALSE)

```

We can see that we need to pool around 1000 T cells to on average get down to bulk variation level,
while we need twice as many of the B cells, likely depending on that the sampling noise is higher
In the B10k dataset due to fewer reads. It is also to be noted that the number of cells that is needed in a pool highly depends on gene expression. For highly expressed genes, a few hundreds are enough, while for lowly expressed genes several thousands are needed.

## 3 BTM score


- Load the template file.

```{r}
templInfo <- DSAVEGetStandardTemplate()
```

- Calculate BTM Score.

```{r}
tcells_btm <- DSAVECalcBTMScore(tcells, templInfo, skipAlignment=FALSE,
                                iterations = 15, useLogTransform=FALSE, 
                                logTPMAddon=1, silent=FALSE)
```

- Load the pre-calculated scores.

```{r}
data(datasetScoresHuman)
```

- Plot the results.

```{r , fig.show = 'asis'}
scores <- data.frame(t(sapply(datasetScoresHuman, 
                              function(x) c(x[[1]], x[[2]]))),
                     stringsAsFactors = F)

scores <- rbind.data.frame(scores,c("T4k", tcells_btm$DSAVEScore))
scores$X2 <- as.numeric(scores$X2)

ggplot(scores, aes( X1)) +
  geom_bar(aes(weight = X2)) +
  coord_flip() +
  ggtitle("Cell-to-cell Variation for Different Datasets") +
  ylab("DSAVE BTM score") + xlab("") +
  theme(axis.text.y = element_text(size = 10))

```

We can see that the T4k dataset has a BTM variation that is comparable to the other datasets and that the technical quality thus is what can be expected for single-cell RNA-Seq.

### 4 Gene-wise variation

- Run `DSAVEGetGeneVariation` on the *B10k* dataset.

```{r}
bcells_gene_variation <- DSAVEGetGeneVariation(as.matrix(bcells), lb=10, iterations = 100, maxNumCells=2000, silent=FALSE)
```

- Plot the Variation per Gene

```{r , fig.show = 'asis'}
id <- order(bcells_gene_variation$logCVDifference, decreasing = T)
df <- as.data.frame(cbind(1:length(id), 
                          bcells_gene_variation$logCVDifference[id]))

ggplot(df, aes(x=V1, y=V2, colour = "B10k")) + 
  geom_line() +
  ggtitle("Variation per Gene") +
  xlab("Gene index") + ylab("BTM variation") +
  theme(legend.justification = c(1, 1),
        legend.title=element_blank(),
        legend.position = c(1, 1),
        legend.text = element_text(size = 8),
        axis.text.x = element_text(size = 10, angle = 90),
        axis.text.y = element_text(size = 10))
```

It is clear that the variation varies much between genes. The stochasticity for a gene can be fairly high, especially for lowly expressed genes. Therefore, it is of interest to compare the p-values as well, where the null hypothesis is that the variation comes from sampling effects.

- Plot the p-value per gene

It is to be noted that these p values are generated with too few iterations; that is why the 
graph is not smooth. We recommend at least 10,000 iterations to get reliable p values, but that takes
much longer to run.


```{r , fig.show = 'asis'}
pvals <- bcells_gene_variation$pVals
id <- order(pvals, decreasing = T)

df <- data.frame(gene = bcells_gene_variation$genes[id], 
                 index = 1:length(pvals[id]), pvals = pvals[id])
df$gene <- as.character(df$gene)

ggplot(df, aes(x=index, y=pvals, colour = "B10k")) + 
  geom_line() +
  ggtitle("p values per gene") +
  xlab("Gene index") + ylab("p value") +
  theme(legend.justification = c(1, 1),
        legend.title=element_blank(),
        legend.position = c(1, 1),
        legend.text = element_text(size = 8),
        axis.text.x = element_text(size = 10, angle = 90),
        axis.text.y = element_text(size = 10))

```

We can see that there are fairly many genes with a low p-value. The p-values are not adjusted for multiple testing, which should be done if the function is used for searching for variable genes.


## 5 Cell-wise variation

- Subsample the *bcells* data to 1000 cells and run DSAVEGetSingleCellDivergence.

```{r}
bcells_id <- sample(1:dim(bcells)[2], 1000)
bcells_cell_divergence <- DSAVEGetSingleCellDivergence(bcells[,bcells_id],
                              minUMIsPerCell = 200, tpmLowerBound = 0,
                              iterations = 15,silent=FALSE)
```

- Estimate the mean log-likelihood

```{r}

numUMIshcatSub2 <- colSums(as.matrix(bcells[,bcells_id]))
linevalYs <- seq(from =  500, to = 10500, by = 250)
linevalXes <- rep(0, length(linevalYs))
for(i in 1:length(linevalYs)){
  ii <- linevalYs[i]
  lb <- ii - 250
  ub <- ii + 250
  sel <- numUMIshcatSub2 >= lb & numUMIshcatSub2 <= ub
  if(sum(sel)!=0){
    linevalXes[i] <- mean(bcells_cell_divergence[sel])
  }else{
    linevalXes[i] <- NA
  }
}
linevalYs <- c(linevalYs, 
               rep(NA, length(numUMIshcatSub2) - length(linevalYs)))
linevalXes <- c(linevalXes, 
                rep(NA, length(numUMIshcatSub2) - length(linevalXes)))
linevalYs[is.na(linevalXes)] <- NA
id <- order(linevalYs, decreasing = F)
linevalXes <- linevalXes[id]
linevalYs <- linevalYs[id]
```


- Plot the UMI Counts vs Cell Divergence

```{r , fig.show = 'asis'}
df <- as.data.frame(cbind(bcells_cell_divergence, colSums(as.matrix(bcells[,bcells_id]))))

ggplot(df, aes(x=bcells_cell_divergence, y=V2, colour = "Individual cell")) + 
  geom_point() +
  ggtitle("UMI Counts vs Cell Divergence") +
  xlab("Log-likelihood") + ylab("UMI counts") +
  theme(legend.justification = c(1, 1),
        legend.title=element_blank(),
        legend.position = c(1, 1),
        legend.text = element_text(size = 8),
        axis.text.x = element_text(size = 10, angle = 90),
        axis.text.y = element_text(size = 10)) +
  geom_path(aes(linevalXes, linevalYs, colour="Mean log-likelihood"))
```

We can see that cells with low number of UMIs are more divergent. Cells below a certain UMI count threshold are usually discarded in a quality control step. We can see that elevating that threshold would likely get rid of more divergent cells, however at the cost of loss of data. Also cells with a high UMI count are on average more divergent; this could be explained by that some of them are doublets, i.e. cases where two or more cells have been accidentally joined and treated as just one cell. Divergence could then come from that the joined cells are of different cell type.

- Plot the Cell Divergence

```{r , fig.show = 'asis'}

id <- order(bcells_cell_divergence, decreasing = F)
df <- as.data.frame(cbind(1:length(bcells_cell_divergence), bcells_cell_divergence[id]))
ggplot(df, aes(x=V1, y=V2, colour = "B10k")) + 
  geom_line() +
  ggtitle("Cell Divergence") +
  xlab("Cell index") + ylab("Log-likelihood") +
  theme(legend.justification = c(1, 0),
        legend.title=element_blank(),
        legend.position = c(1, 0),
        legend.text = element_text(size = 8),
        axis.text.x = element_text(size = 10, angle = 90),
        axis.text.y = element_text(size = 10))
```

We see that the divergence varies much between cells. A certain variation can be expected due to sampling effects though.

