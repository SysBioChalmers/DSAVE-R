---
title: "DSAVE package"
author: "Johan Gustafsson, Juan Inda"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{DSAVE}
  %\VignetteEncoding{UTF-8}
  %\usepackage[utf8]{inputenc}
  %\VignetteEngine{knitr::rmarkdown}
fig_width: 8 
fig_height: 7
editor_options: 
  
  chunk_output_type: console
---


```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE, fig.width = 7,
  comment = "#>"
)
```

## 1 Overview

DSAVE (Down-SAmpling based Variation Estimation) is a package that can be used for 
investigating the cell-to-cell variation in single-cell RNA-Seq data. Specifically, it supports
the following functions:

 * A bulk-like expression profile can be created from single-cell data by pooling cells. DSAVE supports estimation of the cell population size needed to obtain a pooled expression from single-cell RNA-Seq that has the same uncertainty as bulk data.
 * Estimation of the non-sampling related cell-to-cell variation in a dataset, expressed as a single score that is comparable across datasets. This is useful both as a technical quality comparison across datasets and for comparing the performance of clustering algorithms.
 * Finding misclassified and low quality cells, which helps in purifying clusters.

The package works on cell populations containing similar cells. The cells are expected to 
be classified into cell types if the dataset has a mix of cell types, and the total cell 
population need to be divided into populations per cell type to give meaningful results. 

DSAVE supports 4 types of calculations:

 
 
 * DSAVE Cell-Wise Variation - This metric measures the log-likelihood for that a cell is sampled from the 
 mean expression of the cell population. The lower (more negative) the log-likelihood is, the the cell 
 diverges from the mean of the population. The metric is comparable between cells in a cell population,
 but not across cell populations or datasets. The metric can for example be useful for finding thresholds
 for known cell filtration metrics, such as UMI counts and MT gene content.



## 2 Total Variation - estimation of cell population size needed for pooled expression profiles 

 DSAVE Total Variation Estimation - This metric measures the total variation, including sampling noise, 
 for the mean expression over a gene range for a pool of single-cells of a certain size. The metric is 
 useful for determining the pool size needed to obtain the same variation as in for example typical bulk 
 RNA-Seq data. The calculations include generation of sampling noise only (SNO) datasets, which are 
 randomly generated by sampling from a multinomial distribution with probabilities calculated from the 
 mean expression of the cell population.


- Load the package.

```{r}
library(ggplot2)
library(DSAVE)
library(progress)
library(Seurat)
library("plotly")
```

- Download the datasets to analyze. 
The data is first downloaded and then read into a sparse matrix using the Seurat function Read10X. Note that the input to all functions expects a cell population where all cells are of the same cell type. This happens to be the case for the B10k and T4k datasets, but not for PBMC68k.

```{r}
extrDir <- downloadData("http://cf.10xgenomics.com/samples/cell-exp/1.1.0/b_cells/b_cells_filtered_gene_bc_matrices.tar.gz", "B10k")
dataDir = paste0(extrDir,"/filtered_matrices_mex/hg19")
bcells <- Read10X(data.dir = dataDir)

extrDir <- downloadData("http://cf.10xgenomics.com/samples/cell-exp/2.1.0/t_4k/t_4k_filtered_gene_bc_matrices.tar.gz", "T4k")
dataDir = paste0(extrDir,"/filtered_gene_bc_matrices/GRCh38")
tcells <- Read10X(data.dir = dataDir)

extrDir <- downloadData("http://cf.10xgenomics.com/samples/cell-exp/1.1.0/fresh_68k_pbmc_donor_a/fresh_68k_pbmc_donor_a_filtered_gene_bc_matrices.tar.gz", "PBMC68k")
dataDir = paste0(extrDir,"/filtered_matrices_mex/hg19")
pbmc <- Read10X(data.dir = dataDir)
#only use the 25000 first cells to speed up the demo

pbmc = pbmc[,1:25000]
pbmcCellTypes = ctPbmc68k[1:25000]

```

- Calculate the Total Variation for different pool sizes.

```{r}
scTotalVariation_bcells <- DSAVEGetTotalVariationPoolSize(bcells,
        upperBound = 1e5, lowerBound = 5e-1)

scTotalVariation_tcells <- DSAVEGetTotalVariationPoolSize(tcells,
          upperBound = 1e5, lowerBound = 5e-1)

```

- Plot the results

```{r , fig.show = 'asis'}
bulkMean1Vs1 <- rep(mean(bulkTotalVar1vs1[[1]][[2]]), 2)
bulkMean4Vs4 <- rep(mean(bulkTotalVar4vs4[[1]][[2]]), 2)
sc <- rbind(
  cbind(scTotalVariation_bcells$poolSizes, scTotalVariation_bcells$Rs, "B10k", "sc"), 
  cbind(scTotalVariation_tcells$poolSizes, scTotalVariation_tcells$Rs, "T4k", "sc"), 
  cbind(c(pools[1],pools[length(pools)]), 
        bulkMean1Vs1, "single bulk sample", "bulk"),
  cbind(c(pools[1],pools[length(pools)]), 
        bulkMean4Vs4, "mean of 4 bulk samples", "bulk"))

sc <- as.data.frame(sc)
colnames(sc) <- c("PoolSize", "TotalVariation", "Dataset", "DataType")
sc$PoolSize <- as.numeric(as.character(sc$PoolSize))
sc$TotalVariation <- as.numeric(as.character(sc$TotalVariation))

ggplot(sc, aes(x=PoolSize, y=TotalVariation, group = Dataset)) +
  ggtitle("Variation per Cell Pool Size, CPM > 0.5") +
  geom_line(aes(color = Dataset, linetype = DataType)) +
  ylim(0, max(sc$TotalVariation)) +
  theme(legend.title = element_text(size = 10),
        legend.justification = c(1, 1),
        legend.position = c(1, 1),
        legend.text = element_text(size = 8),
        axis.text.x = element_text(size = 10, angle = 90),
        axis.text.y = element_text(size = 10)) + 
  #ylab(bquote('Variation ( ~ R[mean])')) +
  labs(y=expression(paste(Variation (R[mean] ))),
       x="Pool size (number of cells)") +
  guides(linetype = FALSE)

```

We can see that we need to pool around 1500 T cells to on average get down to bulk variation level,
while we need twice as many of the B cells, likely depending on that the sampling noise is higher
in the B10k dataset due to fewer reads. It is also to be noted that the number of cells that is needed 
in a pool highly depends on gene expression. For highly expressed genes, a few hundreds are enough, while 
for lowly expressed genes several thousands are needed.

## 3 Variation score

The DSAVE variation score is a metric describing the non-sampling part of the cell-to-cell variation in single-cell 
RNA-Seq data. It is useful both as a technical quality metric (including the cell type annotation process if applicable)
and as a way to compare different clustering methods on a specific dataset.

To calculate the score, DSAVE divides the variation into two components; sampling noise and 
BTM (Biological, Technical and Misclassification) variation. The sampling noise is a function 
of the number of reads per cell, while the BTM variation contains interesting information 
about technical artefacts, biological variation, and cell misclassifications. The sampling 
noise typically varies between datasets and is often the dominating variation factor, often 
obscuring the BTM variation if not separated with a method such as DSAVE.

BTM variation can be explained the following way: For each mapped read from a cell in a cell 
population, there is a certain chance that this will belong to a certain gene. This probability
is based on the mean expression of that gene in the entire population. If no BTM variation exists,
the reads will be sampled according to these gene probabilities the same way in all cells, and we 
will get only sampling noise. In this context, BTM variation is the variation between cells in the 
probabilities used when sampling reads.

The function uses a template, which is used for making the metric comparable across cell populations and 
even datasets. The template specifies how the algorithm should align the data (downsample etc.) before 
measuring the variation. We provide 3 different templates for human data as part of this package: The standard 
template, for populations of 2000 cells or more, and two variants that require only 1000 and 500 cells, respectively.

We have shown that if the BTM variation of a whole cell population is large compared 
to other datasets, the reason for this is most likely technical; biological variation 
is often smaller when compared over the whole gene range.

The metric's use as a technical quality metric is shown below, while the use for comparing clustering methods 
is shown further down in this document:

- Load the template file.

```{r}
templInfo <- DSAVEGetStandardTemplate()
```

- Calculate BTM Score.

```{r}
tcells_btm <- DSAVECalcBTMScore(tcells, templInfo, skipAlignment=FALSE,
                                iterations = 15, useLogTransform=FALSE, 
                                logTPMAddon=1, silent=FALSE)
```

- Load the pre-calculated scores that are useful for comparison.

```{r}
data(datasetScoresHuman)
```

- Plot the results.

```{r , fig.show = 'asis'}
scores <- data.frame(t(sapply(datasetScoresHuman, 
                              function(x) c(x[[1]], x[[2]]))),
                     stringsAsFactors = F)

scores <- rbind.data.frame(scores,c("T4k", tcells_btm$DSAVEScore))
scores$X2 <- as.numeric(scores$X2)

ggplot(scores, aes( X1)) +
  geom_bar(aes(weight = X2)) +
  coord_flip() +
  ggtitle("Cell-to-cell Variation for Different Datasets") +
  ylab("DSAVE BTM score") + xlab("") +
  theme(axis.text.y = element_text(size = 10))

```

We can see that the T4k dataset has a BTM variation that is comparable to the other datasets and that the technical quality thus is what can be expected for single-cell RNA-Seq.


## 5 Cell-wise variation - detect misclassified cells

- First we visualize the dataset using Seurat
```{r}

so = CreateSeuratObject(counts = pbmc, project = "pbmc", min.cells = 0, min.features = 0)
so <- NormalizeData(so, normalization.method = "LogNormalize", scale.factor = 10000)

#Finds the most variable genes
so <- FindVariableFeatures(so, selection.method = "vst", nfeatures = 2000)

#Make mean and variance the same for all genes:
all.genes <- rownames(so)
so <- ScaleData(so, features = all.genes)

#Principal component analysis
so <- RunPCA(so, features = VariableFeatures(object = so))

so[["extCellTypes"]] = pbmcCellTypes

so <- RunUMAP(so, dims = 1:10)
DimPlot(so, reduction = "umap", group.by = "extCellTypes")

#show data extraction from Seurat:
so <- FindNeighbors(so, dims = 1:10)
so <- FindClusters(so, resolution = 0.5)
DimPlot(so, reduction = "umap")

clust7 = extractSeuratData(so, 7)

```
We show both the cell classification from the authors and the clustering performed by a newer version of Seurat. Although similar, the newer clustering agrees better with the UMAP.

- Now, each cluster has to be examined separately. As an example we look at the dendritic cells
```{r}

dend = pbmc[, pbmcCellTypes == "Dendritic"]

#min(colSums(as.matrix(dend)))

dend_cell_divergence <- DSAVEGetSingleCellDivergence(dend,
                                                     minUMIsPerCell = 200, tpmLowerBound = 0,
                                                     iterations = 15,silent=FALSE)


DSAVEPlotDivergence(dend, dend_cell_divergence)

```

The divergence plot shows each cell's UMI counts plotted against their divergence The most divergent cells are the ones that have the lowest (i.e. most negative) divergence. By investigating the leftmost cells by hoovering over them with the mouse pointer, we can see which 5 genes that contribute the most to the divergence, and thus get an idea about which types of cells aremost divergent. For example, some cells have MT genes as most divergent genes, which may suggest that those are low quality cells. Furthermore, we see that some cells have the gene PPBP as highly divergent, suggesting that they may be megakaryocytes. NKG7 or GNLY show up for other cells, suggesting that they may be NK cells, while immunoglobin genes such as IGLL5 show up for others, suggesting a B cell lineage. 

We also take a look at cluster 7 from Seurat, which supposedly should be the same cell type

```{r}

#also investigate the clustering from Seurat directly
clust7_divergence <- DSAVEGetSingleCellDivergence(clust7,
                                                     minUMIsPerCell = 200, tpmLowerBound = 0,
                                                     iterations = 15,silent=FALSE)

DSAVEPlotDivergence(clust7, clust7_divergence)

```

We see less misclassified cells here in general, although there seem to still be some NK cells present. 

## 6 Compare clustering methods using the DSAVE BTM Variation Score

We can use the DSAVE BTM score to get an idea about which of the cell populations examined above that exhibit the most variation, which could serve as a metric of clustering quality:

```{r}

templ <- DSAVEGetStandardTemplate500();
clust7_score <- DSAVECalcBTMScore(clust7, templ)
dend_score <- DSAVECalcBTMScore(dend, templ)

clust7_score$DSAVEScore
dend_score$DSAVEScore

```

We can see that the score is higher for the authors' classification, suggesting that the newer Seurat clustering leads to more homogenous clusters in this case. 

## 6 Plot the UMI Counts and mitochondrial content vs Cell Divergence to estimate suitable thresholds for cell filtering

- Subsample the *bcells* data to 1000 cells and run. First, UMI counts vs divergence:

```{r}
bcells_id <- sample(1:dim(bcells)[2], 1000)
subb = as.matrix(bcells[,bcells_id])
bcells_cell_divergence <- DSAVEGetSingleCellDivergence(subb,
                                                       minUMIsPerCell = 200, tpmLowerBound = 0,
                                                       iterations = 15,silent=FALSE)
DSAVEDivUMIPlot(subb, bcells_cell_divergence)


```


We can see that cells with low number of UMIs are more divergent. Cells below a certain UMI count threshold are usually discarded in a quality control step. We can see that elevating that threshold would likely get rid of more divergent cells, however at the cost of loss of data. Also cells with a high UMI count are on average more divergent; this could be explained by that some of them are doublets, i.e. cases where two or more cells have been accidentally joined and treated as just one cell. Divergence could then come from that the joined cells are of different cell type.

```{r}

mitoGenes <- grep(pattern = "^MT-", x = row.names(subb), value = TRUE)
fracMT <- colSums(subb[mitoGenes, ])/colSums(subb)

#for mitochondrial content, it makes sense to calculate the divergence without the MT genes, 
#because these in themselves affect the divergence:

subbNoMT = subb[-match(mitoGenes, row.names(subb)),]
bcells_cell_divergence_no_MT <- DSAVEGetSingleCellDivergence(subbNoMT,
                                                       minUMIsPerCell = 200, tpmLowerBound = 0,
                                                       iterations = 15,silent=FALSE)

DSAVEDivParamPlot(bcells_cell_divergence_no_MT, fracMT, "MT Content")

```

It is evident that cells with high mitochondrial content are more divergent, dispite that the the mitochondrial genes are not part of the calculation. This suggest that a high mitochondrial content is a sign of low quality for cells, which is also commonly used in many processing pipelines.

